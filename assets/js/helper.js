/**
 * Created by dweipert on 14.07.16.
 */

const THREE = require( 'three' );
const colorsh = require( './colors' );
const voxels = require( './voxel' );

function scale( x, fromLow, fromHigh, toLow, toHigh ) {
  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow
}

function zoom(delta) {
  var origin = {x: 0, y: 0, z: 0}
  var distance = camera.position.distanceTo(origin)
  var tooFar = distance  > 3000
  var tooClose = distance < 300
  if (delta > 0 && tooFar) return
  if (delta < 0 && tooClose) return
  radius = distance // for mouse drag calculations to be correct
  camera.translateZ( delta )
}

function setIsometricAngle() {

  theta += 90

  camera.position.x = radius * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 )
  camera.position.y = radius * Math.sin( phi * Math.PI / 360 )
  camera.position.z = radius * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 )
  camera.updateMatrix()
}

function getExportCanvas(width, height) {
  var canvas = document.createElement('canvas')
  var ctx = canvas.getContext('2d')
  var source = renderer.domElement
  var width = canvas.width = width || source.width
  var height = canvas.height = height || source.height

  renderer.setSize(width, height)
  camera.aspect = width/height
  camera.updateProjectionMatrix()
  renderer.render(scene, camera)

  ctx.fillStyle = 'rgb(255,255,255)'
  ctx.fillRect(0, 0, width, height)
  ctx.drawImage(source, 0, 0, width, height)

  updateHash()

  var imageData = ctx.getImageData(0, 0, width, height)
  var voxelData = window.location.hash
  var text = 'voxel-painter:' + voxelData

  lsb.encode(imageData.data, text, pickRGB)

  ctx.putImageData(imageData, 0, 0)

  onWindowResize()

  return canvas
}

function importImage(image) {
  var canvas = document.createElement('canvas')
  var ctx = canvas.getContext('2d')
  var width = canvas.width = image.width
  var height = canvas.height = image.height

  ctx.fillStyle = 'rgb(255,255,255)'
  ctx.fillRect(0, 0, width, height)
  ctx.drawImage(image, 0, 0)

  var imageData = ctx.getImageData(0, 0, width, height)
  var text = lsb.decode(imageData.data, pickRGB)

  // ignore images that weren't generated by voxel-painter
  if (text.slice(0, 14) !== 'voxel-painter:') return false

  window.location.hash = text.slice(14)
  buildFromHash()
  return true
}

function setupImageDropImport(element) {
  element.ondragover = function(event) {
    return event.preventDefault(event) && false
  }
  element.ondrop = function(event) {
    event.preventDefault()
    event.stopPropagation()

    if (!event.dataTransfer) return false

    var file = event.dataTransfer.files[0]
    if (!file) return false
    if (!file.type.match(/image/)) return false

    var reader = new FileReader
    reader.onload = function(event) {
      var image = new Image
      image.src = event.target.result
      image.onload = function() {
        if (importImage(image)) return
        alert( 'Looks like that image doesn\'t have any voxels inside it...\nOr this image wasn\'t exported from here.' );
      }
    }
    reader.readAsDataURL(file)
    return false
  }
}

function getDimensions(voxels) {
  var low = [0,0,0], high = [0,0,0]
  voxels.map(function(voxel) {
    if (voxel.x < low[0]) low[0] = voxel.x
    if (voxel.x > high[0]) high[0] = voxel.x
    if (voxel.y < low[1]) low[1] = voxel.y
    if (voxel.y > high[1]) high[1] = voxel.y
    if (voxel.z < low[2]) low[2] = voxel.z
    if (voxel.z > high[2]) high[2] = voxel.z
  })
  return [ (high[0]-low[0]) || 1, (high[1]-low[1]) || 1, (high[2]-low[2]) || 1 ]
}

function buildFromHash(hashMask) {

  var hash = window.location.hash.substr( 1 ),
      hashChunks = hash.split(':'),
      chunks = {};

  animationFrames = []
  for( var j = 0, n = hashChunks.length; j < n; j++ ) {
    chunk = hashChunks[j].split('/')
    chunks[chunk[0]] = chunk[1]
    if (chunk[0].charAt(0) == 'A') {
      animationFrames.push(chunk[1])
    }
  }

  sliderEl.slider( "option", "max", animationFrames.length)

  if ( (!hashMask || hashMask == 'C') && chunks['C'] )
  {
    // decode colors
    var hexColors = chunks['C']
    for(var c = 0, nC = hexColors.length/6; c < nC; c++) {
      var hex = hexColors.substr(c*6,6)
      colors[c] = colorsh.hex2rgb(hex)
      colorsh.addColorToPalette(c)
    }
  }
  var frameMask = 'A'

  if (currentFrame != 0) frameMask = 'A' + currentFrame

  if ( (!hashMask || hashMask == frameMask) && chunks[frameMask] ) {
    // decode geo
    var current = { x: 0, y: 0, z: 0, c: 0 }
    var data = decode( chunks[frameMask] )
    var i = 0, l = data.length

    while ( i < l ) {

      var code = data[ i ++ ].toString( 2 )
      if ( code.charAt( 1 ) == "1" ) current.x += data[ i ++ ] - 32
      if ( code.charAt( 2 ) == "1" ) current.y += data[ i ++ ] - 32
      if ( code.charAt( 3 ) == "1" ) current.z += data[ i ++ ] - 32
      if ( code.charAt( 4 ) == "1" ) current.c += data[ i ++ ] - 32
      if ( code.charAt( 0 ) == "1" ) {
        voxels.addVoxel(current.x * 50 + 25, current.y * 50 + 25, current.z * 50 + 25, current.c)
      }
    }
  }

  updateHash()

}

function updateHash() {
  var data = [], voxels = [], code
  var current = { x: 0, y: 0, z: 0, c: 0 }
  var last = { x: 0, y: 0, z: 0, c: 0 }
  for ( var i in scene.children ) {

    var object = scene.children[ i ]

    if ( object.isVoxel && object !== plane && object !== brush ) {

      current.x = ( object.position.x - 25 ) / 50
      current.y = ( object.position.y - 25 ) / 50
      current.z = ( object.position.z - 25 ) / 50

      var colorString = ['r', 'g', 'b'].map(function(col) { return object.material.color[col] }).join('')
      // this string matching of floating point values to find an index seems a little sketchy
      for (var i = 0; i < colors.length; i++) if (colors[i].join('') === colorString) current.c = i
      voxels.push({x: current.x, y: current.y + 1, z: current.z , c: current.c + 1})

      code = 0

      if ( current.x != last.x ) code += 1000
      if ( current.y != last.y ) code += 100
      if ( current.z != last.z ) code += 10
      if ( current.c != last.c ) code += 1

      code += 10000

      data.push( parseInt( code, 2 ) )

      if ( current.x != last.x ) {

        data.push( current.x - last.x + 32 )
        last.x = current.x

      }

      if ( current.y != last.y ) {

        data.push( current.y - last.y + 32 )
        last.y = current.y

      }

      if ( current.z != last.z ) {

        data.push( current.z - last.z + 32 )
        last.z = current.z

      }

      if ( current.c != last.c ) {

        data.push( current.c - last.c + 32 )
        last.c = current.c

      }
    }
  }

  data = encode(data)
  animationFrames[currentFrame] = data

  var cData = '';
  for (var i = 0; i < colors.length; i++){
    cData += colorsh.rgb2hex(colors[i]);
  }

  var outHash = "#" + (cData ? ("C/" + cData) : '')
  for (var i = 0; i < animationFrames.length; i++) {
    if (i === 0) {
      outHash = outHash + ":A/" + animationFrames[i]
    } else {
      outHash = outHash + ":A" + i + '/' + animationFrames[i]
    }
  }

  // hack to ignore programmatic hash changes
  window.updatingHash = true;

  window.location.replace(outHash);

  setTimeout(function() {
    window.updatingHash = false
  }, 1);

  return voxels;
}

function interact() {
  if (typeof raycaster === 'undefined') return

  if ( window.objectHovered ) {
    window.objectHovered.material.opacity = 1;
    window.objectHovered = null;
  }

  var intersect = getIntersecting();

  if ( intersect ) {
    var normal = intersect.face.normal.clone()
    normal.applyMatrix4( intersect.object.matrixRotationWorld )
    var position = new THREE.Vector3().addVectors( intersect.point, normal )
    var newCube = [Math.floor( position.x / 50 ), Math.floor( position.y / 50 ), Math.floor( position.z / 50 )]

    function updateBrush() {
      brush.position.x = Math.floor( position.x / 50 ) * 50 + 25
      brush.position.y = Math.floor( position.y / 50 ) * 50 + 25
      brush.position.z = Math.floor( position.z / 50 ) * 50 + 25
    }

    if (isAltDown) {
      if (!brush.currentCube) brush.currentCube = newCube
      if (brush.currentCube.join('') !== newCube.join('')) {
        if ( isShiftDown ) {
          if ( intersect.object !== plane ) {
            scene.remove( intersect.object.wireMesh )
            scene.remove( intersect.object )
          }
        } else {
          if (brush.position.y != 2000) addVoxel(brush.position.x, brush.position.y, brush.position.z, color)
        }
      }
      updateBrush()
      updateHash()
      return brush.currentCube = newCube
    } else if ( isShiftDown ) {
      if ( intersect.object !== plane ) {
        objectHovered = intersect.object
        objectHovered.material.opacity = 0.5
        brush.position.y = 2000
        return
      }
    } else {
      updateBrush()
      return
    }
  }
  brush.position.y = 2000
}

function getIntersecting() {
  var intersectable = []
  scene.children.map(function(c) { if (c.isVoxel || c.isPlane) intersectable.push(c); })
  var intersections = raycaster.intersectObjects( intersectable )
  if (intersections.length > 0) {
    var intersect = intersections[ 0 ].object.isBrush ? intersections[ 1 ] : intersections[ 0 ]
    return intersect
  }
}

function exportFunction(voxels) {
  var dimensions = getDimensions(voxels)
  voxels = voxels.map(function(v) { return [v.x, v.y, v.z, v.c + 1]})
  var funcString = "var voxels = " + JSON.stringify(voxels) + ";"
  funcString += 'var dimensions = ' + JSON.stringify(dimensions) + ';'
  funcString += 'voxels.map(function(voxel) {' +
                'game.setBlock([position.x + voxel[0], position.y + voxel[1], position.z + voxel[2]], voxel[3])' +
                '});'
  return funcString
}

function decode( string ) {
  var output = [];
  string.split('').forEach( function ( v ) { output.push( "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf( v ) ) } );
  return output;
}

function encode( array ) {
  var output = "";
  array.forEach( function ( v ) { output += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt( v ) } );
  return output;
}

module.exports = {

  scale: scale,
  zoom: zoom,

  setIsometricAngle: setIsometricAngle,

  getExportCanvas: getExportCanvas,
  importImage: importImage,
  setupImageDropImport: setupImageDropImport,
  getDimensions: getDimensions,

  buildFromHash: buildFromHash,
  updateHash: updateHash,

  interact: interact,

  getIntersecting: getIntersecting,
  exportFunction: exportFunction,

  decode: decode,
  encode: encode

};
